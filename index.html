<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <title>ğŸ§  NeuroQuest - Ø±Ø­Ù„Ø© Ø§Ù„Ø¯Ù…Ø§Øº</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background-color: #f5faff;
      margin: 0;
      padding: 0;
    }

    #startScreen, #certificateScreen {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #e6f2ff;
      text-align: center;
    }

    #startScreen h1, #certificateScreen h1 {
      font-size: 3em;
      color: #007acc;
    }

    #startScreen p, #certificateScreen p {
      font-size: 1.2em;
      margin: 20px;
    }

    button {
      padding: 15px 30px;
      font-size: 1em;
      background-color: #007acc;
      color: white;
      border: none;
      cursor: pointer;
      border-radius: 8px;
    }

    #gameContainer {
      text-align: center;
      padding: 20px;
      display: none;
    }

    #progressBar {
      background-color: #d0ebff;
      color: #003366;
      padding: 10px;
      font-weight: bold;
      display: inline-block;
      margin-bottom: 10px;
      border-radius: 5px;
    }

    #gameCanvas {
      border: 2px solid #007acc;
      background-color: white;
      margin: 20px auto;
      display: block;
    }

    #infoBox {
      margin-top: 15px;
      padding: 10px;
      background-color: #e6f2ff;
      color: #003366;
      display: inline-block;
      max-width: 600px;
      border-radius: 8px;
    }

    #nextLevelBtn {
      margin-top: 10px;
    }
  </style>
</head>
<body>

  <!-- Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© -->
  <div id="startScreen">
    <h1>ğŸ§  NeuroQuest</h1>
    <p>Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨Ùƒ ÙÙŠ Ø±Ø­Ù„Ø© Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¯Ù…Ø§Øº!</p>
    <p>Ù‡Ø¯ÙÙƒ Ù‡Ùˆ Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø®Ù„Ø§ÙŠØ§ Ø§Ù„Ø¹ØµØ¨ÙŠØ© Ù„Ø¥Ù†Ù‚Ø§Ø° Ø§Ù„Ù…Ø±ÙŠØ¶ Ø£Ø­Ù…Ø¯.</p>
    <button onclick="startGame()">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø±Ø­Ù„Ø©</button>
  </div>

  <!-- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„Ø¹Ø¨Ø© -->
  <div id="gameContainer">
    <h1 id="levelTitle">ğŸ§  Ù…Ø³ØªÙˆÙ‰ 1: Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø®Ù„ÙŠØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ©</h1>
    <div id="progressBar">Ø§Ù„Ù…Ø³ØªÙˆÙ‰: <span id="levelNum">1</span></div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="infoBox">Ø§Ø³Ø­Ø¨ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ ÙˆØ¶Ø¹Ù‡Ø§ ÙÙŠ Ø£Ù…Ø§ÙƒÙ†Ù‡Ø§ Ø§Ù„ØµØ­ÙŠØ­Ø©</div>
    <div id="nextLevelBtn" style="display: none;"><button onclick="nextLevel()">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ</button></div>
  </div>

  <!-- Ø´Ù‡Ø§Ø¯Ø© Ø§Ù„Ø¥ØªÙ…Ø§Ù… -->
  <div id="certificateScreen" style="display: none;">
    <h1>ğŸ“œ Ø´Ù‡Ø§Ø¯Ø© Ø¥Ù†Ø¬Ø§Ø²</h1>
    <p>Ù„Ù‚Ø¯ Ø£ØªÙ…Ù…Øª Ø¬Ù…ÙŠØ¹ Ù…Ø³ØªÙˆÙŠØ§Øª Ù„Ø¹Ø¨Ø© NeuroQuest!</p>
    <p><strong>ğŸ§  Ø£Ù†Øª Ø§Ù„Ø¢Ù† Ù‚Ø§Ø¯Ø± Ø¹Ù„Ù‰ ÙÙ‡Ù… ØªØ±ÙƒÙŠØ¨ Ø§Ù„Ø®Ù„ÙŠØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ©!</strong></p>
    <p><strong>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù†Ù‚Ø§Ø·: <span id="totalScore">0</span></strong></p>
    <button onclick="restartGame()">Ø§Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</button>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    let currentLevel = 1;
    let score = 0;

    // Ø§Ù„ØµÙˆØ± Ø§Ù„Ù…Ø¯Ù…Ø¬Ø© Ø¨ØµÙŠØºØ© Base64
    const neuronImages = {
      "Ø¬Ø³Ù… Ø§Ù„Ø®Ù„ÙŠØ©": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAyCAIAAAA...",
      "Ø§Ù„Ù…Ø­ÙˆØ± (Axon)": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAyCAIAAAA...",
      "Ø§Ù„Ø´Ø¬Ø±Ø© Ø§Ù„Ø¹ØµØ¨ÙŠØ©": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAyCAIAAAA...",
      "Ø§Ù„ØºØ´Ø§Ø¡ Ø§Ù„Ù…Ø§ÙŠÙ„ÙŠÙ†ÙŠ": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAyCAIAAAA...",
      "Ø§Ù„ØªØ´Ø§Ø¨Ùƒ Ø§Ù„Ø¹ØµØ¨ÙŠ": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAyCAIAAAA..."
    };

    // Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª
    const levels = [
      {
        title: "Ù…Ø³ØªÙˆÙ‰ 1: Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø®Ù„ÙŠØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ©",
        parts: [
          { name: "Ø¬Ø³Ù… Ø§Ù„Ø®Ù„ÙŠØ©", x: 400, y: 300, placed: false, correctX: 380, correctY: 280 },
          { name: "Ø§Ù„Ù…Ø­ÙˆØ± (Axon)", x: 500, y: 300, placed: false, correctX: 480, correctY: 280 },
          { name: "Ø§Ù„Ø´Ø¬Ø±Ø© Ø§Ù„Ø¹ØµØ¨ÙŠØ©", x: 300, y: 300, placed: false, correctX: 280, correctY: 280 }
        ],
        info: {
          "Ø¬Ø³Ù… Ø§Ù„Ø®Ù„ÙŠØ©": "Ù‡Ùˆ Ù…Ø±ÙƒØ² Ø§Ù„Ø®Ù„ÙŠØ© ÙˆÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ù†ÙˆØ§Ø©.",
          "Ø§Ù„Ù…Ø­ÙˆØ± (Axon)": "ÙŠÙ†Ù‚Ù„ Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ù…Ù† Ø§Ù„Ø®Ù„ÙŠØ© Ø¥Ù„Ù‰ Ø§Ù„Ø®Ù„Ø§ÙŠØ§ Ø§Ù„Ø£Ø®Ø±Ù‰.",
          "Ø§Ù„Ø´Ø¬Ø±Ø© Ø§Ù„Ø¹ØµØ¨ÙŠØ©": "ØªØ³ØªÙ‚Ø¨Ù„ Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ù…Ù† Ø§Ù„Ø®Ù„Ø§ÙŠØ§ Ø§Ù„Ø¹ØµØ¨ÙŠØ© Ø§Ù„Ù…Ø¬Ø§ÙˆØ±Ø©."
        }
      },
      {
        title: "Ù…Ø³ØªÙˆÙ‰ 2: ØªØ±ØªÙŠØ¨ Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø¥Ø´Ø§Ø±Ø©",
        parts: [
          { name: "Ø§Ù„ØªØ­ÙÙŠØ²", x: 100, y: 200, placed: false, correctX: 100, correctY: 200 },
          { name: "Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¥Ø´Ø§Ø±Ø©", x: 200, y: 200, placed: false, correctX: 200, correctY: 200 },
          { name: "Ø§Ù„Ù†ÙˆØ§Ø©", x: 300, y: 200, placed: false, correctX: 300, correctY: 200 },
          { name: "Ø§Ù„Ù…Ø­ÙˆØ±", x: 400, y: 200, placed: false, correctX: 400, correctY: 200 },
          { name: "Ø§Ù„ØªØ´Ø§Ø¨Ùƒ", x: 500, y: 200, placed: false, correctX: 500, correctY: 200 }
        ],
        explanation: "Ø±ØªØ¨ Ø®Ø·ÙˆØ§Øª Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ©"
      },
      {
        title: "Ù…Ø³ØªÙˆÙ‰ 3: ØªÙˆØµÙŠÙ„ Ø§Ù„Ø®Ù„Ø§ÙŠØ§",
        circles: [
          { x: 100, y: 100, radius: 30, label: "Ø®Ù„ÙŠØ© 1", connected: false },
          { x: 300, y: 100, radius: 30, label: "Ø®Ù„ÙŠØ© 2", connected: false },
          { x: 500, y: 100, radius: 30, label: "Ø®Ù„ÙŠØ© 3", connected: false }
        ],
        explanation: "ÙˆØµÙ„ Ø¨ÙŠÙ† Ø§Ù„Ø®Ù„Ø§ÙŠØ§ Ù„ØªÙƒÙˆÙ† Ø´Ø¨ÙƒØ© Ø¹ØµØ¨ÙŠØ© ÙƒØ§Ù…Ù„Ø©"
      },
      {
        title: "Ù…Ø³ØªÙˆÙ‰ 4: Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ø¹Ø·Ù„",
        parts: [
          { name: "Ø¬Ø³Ù… Ø§Ù„Ø®Ù„ÙŠØ©", x: 400, y: 300, broken: true },
          { name: "Ø§Ù„Ù…Ø­ÙˆØ±", x: 500, y: 300, broken: false },
          { name: "Ø§Ù„Ø´Ø¬Ø±Ø© Ø§Ù„Ø¹ØµØ¨ÙŠØ©", x: 300, y: 300, broken: false }
        ],
        explanation: "Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø°ÙŠ ÙŠØ¨Ø¯Ùˆ Ù…Ø¹Ø·ÙˆØ¨Ù‹Ø§"
      },
      {
        title: "Ù…Ø³ØªÙˆÙ‰ 5: Ø¨Ù†Ø§Ø¡ Ø±Ø¯ Ø§Ù„ÙØ¹Ù„",
        steps: [
          { name: "Ø§Ù„ØªØ­ÙÙŠØ²", x: 50, y: 100, placed: false },
          { name: "Dendrite", x: 150, y: 100, placed: false },
          { name: "Ø§Ù„Ù†ÙˆØ§Ø©", x: 250, y: 100, placed: false },
          { name: "Axon", x: 350, y: 100, placed: false },
          { name: "Synapse", x: 450, y: 100, placed: false }
        ],
        targets: [
          { name: "Ø§Ù„ØªØ­ÙÙŠØ²", x: 50, y: 200 },
          { name: "Dendrite", x: 150, y: 200 },
          { name: "Ø§Ù„Ù†ÙˆØ§Ø©", x: 250, y: 200 },
          { name: "Axon", x: 350, y: 200 },
          { name: "Synapse", x: 450, y: 200 }
        ],
        explanation: "Ø§Ø±Ø¨Ø· ÙƒÙ„ Ø®Ø·ÙˆØ© Ø¨Ù…ÙˆØ¶Ø¹Ù‡Ø§ Ø§Ù„ØµØ­ÙŠØ­ Ù„Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„Ø¹ØµØ¨ÙŠØ©"
      }
    ];

    let draggedItem = null;
    let imagesLoaded = 0;
    const images = {};

    function startGame() {
      document.getElementById("startScreen").style.display = "none";
      document.getElementById("gameContainer").style.display = "block";
      document.getElementById("levelTitle").innerText = levels[currentLevel - 1].title;
      document.getElementById("levelNum").innerText = currentLevel;
      loadImages();
    }

    function nextLevel() {
      if (currentLevel < levels.length) {
        currentLevel++;
        document.getElementById("levelTitle").innerText = levels[currentLevel - 1].title;
        document.getElementById("levelNum").innerText = currentLevel;
        resetLevel();
        draw();
      } else {
        showCertificate();
      }
    }

    function showCertificate() {
      document.getElementById("gameContainer").style.display = "none";
      document.getElementById("certificateScreen").style.display = "block";
      document.getElementById("totalScore").innerText = score;
    }

    function restartGame() {
      currentLevel = 1;
      score = 0;
      document.getElementById("certificateScreen").style.display = "none";
      document.getElementById("gameContainer").style.display = "block";
      document.getElementById("levelTitle").innerText = levels[0].title;
      document.getElementById("levelNum").innerText = 1;
      resetLevel();
      draw();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const level = levels[currentLevel - 1];

      if (currentLevel === 1) {
        level.parts.forEach(part => {
          if (images[part.name]) {
            ctx.drawImage(images[part.name], part.x, part.y, 40, 40);
          }
          ctx.setLineDash([5]);
          ctx.strokeStyle = "#999";
          ctx.strokeRect(part.correctX, part.correctY, 40, 40);
          ctx.setLineDash([]);
        });

        if (level.parts.every(p => p.placed)) {
          document.getElementById("infoBox").innerHTML = `
            ğŸ“˜ ØªÙ…! ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø´Ø§Ù‡Ø¯Ø© ÙƒÙŠÙ ØªØ¹Ù…Ù„ Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø§Ù„Ø¹ØµØ¨ÙŠØ©.<br>
            <small>Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù„Ø¹Ø¨...</small>
          `;
          document.getElementById("nextLevelBtn").style.display = "block";
        }

      } else if (currentLevel === 2) {
        level.parts.forEach((part, i) => {
          if (images[part.name]) {
            ctx.drawImage(images[part.name], part.x, part.y, 40, 40);
          }
        });

        if (isOrderedCorrectly()) {
          document.getElementById("infoBox").innerHTML = `âœ… Ø±Ø§Ø¦Ø¹! Ù„Ù‚Ø¯ Ø±ØªØ¨Øª Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­.`;
          document.getElementById("nextLevelBtn").style.display = "block";
          score += 10;
        }

      } else if (currentLevel === 3) {
        level.circles.forEach(circle => {
          ctx.beginPath();
          ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
          ctx.fillStyle = circle.connected ? "#007acc" : "#ddd";
          ctx.fill();
          ctx.fillStyle = "#000";
          ctx.textAlign = "center";
          ctx.font = "14px Arial";
          ctx.fillText(circle.label, circle.x, circle.y + 5);
        });

        level.lines?.forEach(line => {
          ctx.beginPath();
          ctx.moveTo(line.from.x, line.from.y);
          ctx.lineTo(line.to.x, line.to.y);
          ctx.strokeStyle = "#007acc";
          ctx.stroke();
        });

        if (level.circles.every(c => c.connected)) {
          document.getElementById("infoBox").innerHTML = `âœ… ØªÙ…! Ù„Ù‚Ø¯ Ø¨Ù†ÙŠØª Ø´Ø¨ÙƒØ© Ø¹ØµØ¨ÙŠØ© ÙƒØ§Ù…Ù„Ø©`;
          document.getElementById("nextLevelBtn").style.display = "block";
        }

      } else if (currentLevel === 4) {
        level.parts.forEach(part => {
          if (images[part.name]) {
            ctx.drawImage(images[part.name], part.x, part.y, 40, 40);
          }
        });
        document.getElementById("infoBox").innerText = "Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ø¹Ø·ÙˆØ¨";

      } else if (currentLevel === 5) {
        level.steps.forEach(step => {
          if (images[step.name]) {
            ctx.drawImage(images[step.name], step.x, step.y, 40, 40);
          }
        });

        level.targets.forEach(target => {
          ctx.strokeStyle = "#999";
          ctx.strokeRect(target.x, target.y, 40, 40);
        });

        document.getElementById("infoBox").innerText = "Ø§Ø³Ø­Ø¨ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ ÙˆØ¶Ø¹Ù‡Ø§ ÙÙŠ Ø£Ù…Ø§ÙƒÙ†Ù‡Ø§";
      }
    }

    function isOrderedCorrectly() {
      return levels[1].parts.every((p, i) => p.order === i);
    }

    function resetLevel() {
      const level = levels[currentLevel - 1];
      if (level.parts) level.parts.forEach(p => p.placed = false);
      if (level.circles) level.circles.forEach(c => c.connected = false);
      document.getElementById("nextLevelBtn").style.display = "none";
      document.getElementById("infoBox").innerText = "Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù…Ø³ØªÙˆÙ‰!";
      draw();
    }

    function loadImages() {
      levels.forEach(level => {
        level.parts?.forEach(part => {
          const img = new Image();
          img.src = neuronImages[part.name] || "";
          img.onload = () => {
            images[part.name] = img;
            imagesLoaded++;
            if (imagesLoaded === getTotalParts()) draw();
          };
        });
      });
    }

    function getTotalParts() {
      let count = 0;
      levels.forEach(level => {
        if (level.parts) count += level.parts.length;
      });
      return count;
    }

    function connectCircles(clickedCircle) {
      if (!clickedCircle.connected) {
        clickedCircle.connected = true;
        levels[2].lines = levels[2].lines || [];
        levels[2].lines.push({
          from: { x: clickedCircle.x, y: clickedCircle.y },
          to: { x: clickedCircle.x + 100, y: clickedCircle.y }
        });
        draw();
      }
    }

    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const level = levels[currentLevel - 1];

      if (currentLevel === 1) {
        level.parts.forEach(part => {
          if (!part.placed &&
              mouseX > part.x && mouseX < part.x + 40 &&
              mouseY > part.y && mouseY < part.y + 40) {
            draggedItem = part;
          }
        });
      } else if (currentLevel === 2) {
        level.parts.forEach(part => {
          if (!part.moved) {
            if (mouseX > part.x && mouseX < part.x + 40 &&
                mouseY > part.y && mouseY < part.y + 40) {
              draggedItem = part;
            }
          }
        });
      } else if (currentLevel === 3) {
        level.circles.forEach(circle => {
          const dx = mouseX - circle.x;
          const dy = mouseY - circle.y;
          if (Math.sqrt(dx * dx + dy * dy) < circle.radius) {
            connectCircles(circle);
          }
        });
      } else if (currentLevel === 4) {
        level.parts.forEach(part => {
          if (mouseX > part.x && mouseX < part.x + 40 &&
              mouseY > part.y && mouseY < part.y + 40) {
            if (part.broken) {
              score += 10;
              alert("âœ… Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ ÙƒØ§Ù† Ù…Ø¹Ø·ÙˆØ¨Ø§Ù‹! ØªÙ‡Ø§Ù†ÙŠÙ†Ø§!");
              nextLevel();
            } else {
              alert("âŒ Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­.");
            }
          }
        });
      } else if (currentLevel === 5) {
        level.steps.forEach(step => {
          if (mouseX > step.x && mouseX < step.x + 40 &&
              mouseY > step.y && mouseY < step.y + 40) {
            draggedItem = step;
          }
        });
      }

      draw();
    });

    canvas.addEventListener("mousemove", e => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      if (draggedItem && currentLevel === 1) {
        draggedItem.x = mouseX - 20;
        draggedItem.y = mouseY - 20;
        checkPlacement(draggedItem);
      } else if (draggedItem && currentLevel === 2) {
        draggedItem.x = mouseX - 20;
        draggedItem.y = mouseY - 20;
      } else if (draggedItem && currentLevel === 5) {
        draggedItem.x = mouseX - 20;
        draggedItem.y = mouseY - 20;
      }

      draw();
    });

    canvas.addEventListener("mouseup", () => {
      const level = levels[currentLevel - 1];

      if (draggedItem && currentLevel === 1) {
        const dx = Math.abs(draggedItem.x - draggedItem.correctX);
        const dy = Math.abs(draggedItem.y - draggedItem.correctY);
        if (dx < 20 && dy < 20) {
          draggedItem.x = draggedItem.correctX;
          draggedItem.y = draggedItem.correctY;
          draggedItem.placed = true;
        }
      } else if (draggedItem && currentLevel === 2) {
        draggedItem.moved = true;
        for (let i = 0; i < level.parts.length; i++) {
          if (draggedItem === level.parts[i]) {
            draggedItem.order = i;
            break;
          }
        }
      } else if (draggedItem && currentLevel === 5) {
        level.targets.forEach(target => {
          const dx = draggedItem.x - target.x;
          const dy = draggedItem.y - target.y;
          if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
            draggedItem.x = target.x;
            draggedItem.y = target.y;
            draggedItem.placed = true;
          }
        });
      }

      draggedItem = null;
      draw();
    });

    function checkPlacement(part) {
      const dx = Math.abs(part.x - part.correctX);
      const dy = Math.abs(part.y - part.correctY);
      if (dx < 20 && dy < 20) {
        part.x = part.correctX;
        part.y = part.correctY;
        part.placed = true;
        score += 10;
      }
    }

    function startGame() {
      document.getElementById("startScreen").style.display = "none";
      document.getElementById("gameContainer").style.display = "block";
      document.getElementById("levelTitle").innerText = levels[0].title;
      loadImages();
    }

    function nextLevel() {
      if (currentLevel < levels.length) {
        currentLevel++;
        document.getElementById("levelTitle").innerText = levels[currentLevel - 1].title;
        document.getElementById("levelNum").innerText = currentLevel;
        resetLevel();
        draw();
      } else {
        showCertificate();
      }
    }

    function showCertificate() {
      document.getElementById("gameContainer").style.display = "none";
      document.getElementById("certificateScreen").style.display = "block";
      document.getElementById("totalScore").innerText = score;
    }

    function restartGame() {
      currentLevel = 1;
      score = 0;
      document.getElementById("certificateScreen").style.display = "none";
      document.getElementById("gameContainer").style.display = "block";
      document.getElementById("levelTitle").innerText = levels[0].title;
      document.getElementById("levelNum").innerText = 1;
      resetLevel();
      draw();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const level = levels[currentLevel - 1];

      if (currentLevel === 1) {
        level.parts.forEach(part => {
          if (images[part.name]) {
            ctx.drawImage(images[part.name], part.x, part.y, 40, 40);
          }
          ctx.setLineDash([5]);
          ctx.strokeStyle = "#999";
          ctx.strokeRect(part.correctX, part.correctY, 40, 40);
          ctx.setLineDash([]);
        });

        if (level.parts.every(p => p.placed)) {
          document.getElementById("infoBox").innerHTML = `
            ğŸ“˜ ØªÙ…! ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø´Ø§Ù‡Ø¯Ø© ÙƒÙŠÙ ØªØ¹Ù…Ù„ Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø§Ù„Ø¹ØµØ¨ÙŠØ©.<br>
            <small>Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù„Ø¹Ø¨...</small>
          `;
          document.getElementById("nextLevelBtn").style.display = "block";
        }

      } else if (currentLevel === 2) {
        level.parts.forEach((part, i) => {
          if (images[part.name]) {
            ctx.drawImage(images[part.name], part.x, part.y, 40, 40);
          }
        });

        if (isOrderedCorrectly()) {
          document.getElementById("infoBox").innerHTML = `âœ… Ø±Ø§Ø¦Ø¹! Ù„Ù‚Ø¯ Ø±ØªØ¨Øª Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­.`;
          document.getElementById("nextLevelBtn").style.display = "block";
          score += 10;
        }

      } else if (currentLevel === 3) {
        level.circles.forEach(circle => {
          ctx.beginPath();
          ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
          ctx.fillStyle = circle.connected ? "#007acc" : "#ddd";
          ctx.fill();
          ctx.fillStyle = "#000";
          ctx.textAlign = "center";
          ctx.font = "14px Arial";
          ctx.fillText(circle.label, circle.x, circle.y + 5);
        });

        level.lines?.forEach(line => {
          ctx.beginPath();
          ctx.moveTo(line.from.x, line.from.y);
          ctx.lineTo(line.to.x, line.to.y);
          ctx.strokeStyle = "#007acc";
          ctx.stroke();
        });

        if (level.circles.every(c => c.connected)) {
          document.getElementById("infoBox").innerHTML = `âœ… ØªÙ…! Ù„Ù‚Ø¯ Ø¨Ù†ÙŠØª Ø´Ø¨ÙƒØ© Ø¹ØµØ¨ÙŠØ© ÙƒØ§Ù…Ù„Ø©`;
          document.getElementById("nextLevelBtn").style.display = "block";
          score += 10;
        }

      } else if (currentLevel === 4) {
        level.parts.forEach(part => {
          if (images[part.name]) {
            ctx.drawImage(images[part.name], part.x, part.y, 40, 40);
          }
        });
        document.getElementById("infoBox").innerText = "Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ø¹Ø·ÙˆØ¨";

      } else if (currentLevel === 5) {
        level.steps.forEach(step => {
          if (images[step.name]) {
            ctx.drawImage(images[step.name], step.x, step.y, 40, 40);
          }
        });

        level.targets.forEach(target => {
          ctx.strokeStyle = "#999";
          ctx.strokeRect(target.x, target.y, 40, 40);
        });

        document.getElementById("infoBox").innerText = "Ø§Ø³Ø­Ø¨ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ ÙˆØ¶Ø¹Ù‡Ø§ ÙÙŠ Ø£Ù…Ø§ÙƒÙ†Ù‡Ø§";
      }
    }

    function isOrderedCorrectly() {
      return levels[1].parts.every((p, i) => p.order === i);
    }

    function resetLevel() {
      const level = levels[currentLevel - 1];
      if (level.parts) level.parts.forEach(p => p.placed = false);
      if (level.circles) level.circles.forEach(c => c.connected = false);
      document.getElementById("nextLevelBtn").style.display = "none";
      document.getElementById("infoBox").innerText = "Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù…Ø³ØªÙˆÙ‰!";
      draw();
    }

    function loadImages() {
      levels.forEach(level => {
        level.parts?.forEach(part => {
          const img = new Image();
          img.src = neuronImages[part.name] || "";
          img.onload = () => {
            images[part.name] = img;
            imagesLoaded++;
            if (imagesLoaded === getTotalParts()) draw();
          };
        });
      });
    }

    function getTotalParts() {
      let count = 0;
      levels.forEach(level => {
        if (level.parts) count += level.parts.length;
      });
      return count;
    }

    // Ø¨Ø¯Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±
    let imagesLoaded = 0;
    const images = {};
    levels.forEach(level => {
      level.parts?.forEach(part => {
        const img = new Image();
        img.src = neuronImages[part.name] || "";
        img.onload = () => {
          images[part.name] = img;
          imagesLoaded++;
          if (imagesLoaded === getTotalParts()) draw();
        };
      });
    });
  </script>
</body>
</html>
